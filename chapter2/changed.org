* 演示
guile> (define x (cons 1 2))
guile> (define y (cons 3 4))
guile> (define z (cons x y))
guile> x
(1 . 2)
guile> y
(3 . 4)
guile> z
((1 . 2) 3 . 4)
; car and cdr
guile> (car z)
(1 . 2)
guile> (cdr z)
(3 . 4)
; "((1 . 2) 3 . 4)"是一种简写
; "如果右支是一个表，当然也可以表示为 (Left . (List)) ，但是此时我们一般把点省略掉"
guile> '((1 . 2) . (3 . 4))
((1 . 2) 3 . 4)
guile>
** REPORT ; "如果右支是一个表，当然也可以表示为 (Left . (List)) ，但是此时我们一般把点省略掉"
CLOSED: [2013-04-26 五 22:05]
- 我认为，如果右支是一个表，当然也可以表示为 (Left . (List)) ，但是此时我们一般把点和括号都省略掉
  #+BEGIN_EXAMPLE
  guile> (cons '(1 . 2) '(1 2))    ;; 右支是一个表，省略了点和括号
  ((1 . 2) 1 2)
  #+END_EXAMPLE
* 我以前的笔记
** (cons a b)
*** REPORT (cons x y)要求y是一个表，它返回一个表，这个表的第一个元素是x，其后是y中的所有元素
CLOSED: [2013-04-26 五 21:17]
> (cons 'a '(b c))
(a b c)
> (cons 'a (cons 'b (cons 'c '())))
(a b c)
**** FIXED 我认为(cons x y)不一定要求y是一个表，可以是其他数据类型
CLOSED: [2013-04-26 五 21:17]
- 因为(cons 1 2)成立，但2不是表
  #+BEGIN_EXAMPLE
  guile> (cons 1 '(1 . 2))
  (1 1 . 2)
  guile> (list? '(1 . 2))
  #f
  guile> (pair? '(1 . 2))
  #t
  #+END_EXAMPLE  
**** FIXED 我认为(cons x y)返回的不一定是一个表，而是一个序对
CLOSED: [2013-04-26 五 21:18]
- http://www.schemers.org/Documents/Standards/R5RS/HTML/r5rs-Z-H-9.html#%_idx_390
- procedure:  (cons obj1 obj2) 
  Returns a newly allocated *pair* whose car is obj1 and whose cdr is obj2.
  The pair is guaranteed to be different (in the sense of eqv?) from every existing object.
  #+BEGIN_EXAMPLE
  guile> (pair? (cons 'a '()))
  #t
  guile> (list? (cons 'a '()))    ;; 返回了 list
  #t
  guile> (pair? (cons 'a 3))    ;; 返回了 pair
  #t
  guile> (list? (cons 'a 3))
  #f
  #+END_EXAMPLE  
**** REPORT 关于 *list?*                                      :判断参数是否是一个list:
CLOSED: [2013-04-26 五 21:29]
- http://www.schemers.org/Documents/Standards/R5RS/HTML/r5rs-Z-H-9.html#%_idx_414
- library procedure:  (list? obj) 
  Returns #t if obj is a list, otherwise returns #f.
  By definition, all lists have finite length and are terminated by the empty list.
  #+BEGIN_EXAMPLE
  (list? '(a b c))             ===>  #t
  (list? '())                  ===>  #t
  (list? '(a . b))             ===>  #f
  (let ((x (list 'a)))
    (set-cdr! x x)
    (list? x))                 ===>  #f
  #+END_EXAMPLE    
**** REPORT 关于 *pair?*                                      :判断参数是否是一个pair:
CLOSED: [2013-04-26 五 21:29]
- http://www.schemers.org/Documents/Standards/R5RS/HTML/r5rs-Z-H-9.html#%_idx_388
- procedure:  (pair? obj) 
  Pair? returns #t if obj is a pair, and otherwise returns #f.
  #+BEGIN_EXAMPLE
  (pair? '(a . b))                ===>  #t
  (pair? '(a b c))                ===>  #t
  (pair? '())                     ===>  #f
  (pair? '#(a b))                 ===>  #f  
  #+END_EXAMPLE    
*** a as car, b as cdr
: (define x (cons 1 2))
:
: (define y (cons 3 4))
:
: (define z (cons x y))
:
: (define yy (cons 5 6))
:
: (define zz (cons z yy))
:
: guile> zz
: (((1 . 2) 3 . 4) 5 . 6)
* 参考
[]
Lisp 入门/第三章 构造表
维基教科书，自由的教学读本
< Lisp 入門
目录 [隐藏]
1 第三章 构造表
1.1 CONS 操作符
1.2 S 表达式
1.3 append 函数
1.4 LIST 函数
[编辑]第三章 构造表
[编辑]CONS 操作符
我们刚刚学习了如何拆分一个表，现在学习如何合并一个表。 CONS 操作符就是做这件事情的。
假设有一个列表 (1 2 3) ，我们做一下 CAR 操作：
(car '(1 2 3))
返回 1 。
我们再做一下 CDR 操作：
(cdr '(1 2 3))
返回 (2 3) 。
CONS 操作符的作用就是将拆开的表连起来。
(cons 1 '(2 3))
返回的将是原来的列表 (1 2 3) 。
[编辑]S 表达式
cons 操作符的第二个参数要是一个列表，才能返回一个列表。否则：
(cons 2 3)
返回
(2 . 3)
这次中间有一个点。为什么呢？
因为，表实际上是一个树（二叉树）。我们上面所用到的带括号的式子被称为 S表达式。而在S表达式中， 二叉树在表示为 (Left . Right) 。
如果左支是一个表，则就会成为如下形式。
((List) . Right)
如果右支是一个表，当然也可以表示为 (Left . (List)) ，但是此时我们一般把点省略掉，写成
(Left List)
你现在可能有些晕，用一段表达式表示就很清晰了，如下
'(3 . (2 3))
(3 2 3)
CONS操作符的作用是将两棵树连接成一棵树。
那么现在你能回答为什么CDR操作符会取出除第一个外的所有元素了吗，因为它的实质是取二叉树的右支。
总之CONS操作符的作用是连接一个元素与一个表（顺序不可颠倒）。
(cons 2 '(2 3))
(2 2 3)
如果要连接三个或以上的元素，要这样
(cons 1 (cons 2 '(3)))
(1 2 3)
真正有点实质性的是这个式子
(cons 1 (cons 2 (cons 3 nil))) ;;; (1 2 3)
(cons 3 nil) ;;; (3)
如果二叉树的右支是NIL，那么连NIL都省略掉。如
'(3 . Nil) ;;; (3)
一件有趣的事情是这样
(cdr '(3)) ;;; NIL
[编辑]append 函数
append函数的作用是连接两个表。
>(append '(3 3) '(4 4))
(3 3 4 4)
形象点说，它会把最外一层括号去掉，然后连接。比如
>(append '((3)) '(4 4))
((3) 4 4)
[编辑]LIST 函数
LIST 函数的意义是将所有的参数放入一个表中并返回之。
>(list 1 1 1 1)
(1 1 1 1)
>(list '(2 3) '(2) 1 2)
((2 3) (2) 1 2)
2013/4/21 <liyangmyname@sina.com>:
> (cons (cons 1 2) (cons 3 4))
